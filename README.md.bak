# SwiftSnapshot üìã

**Generate type-safe, human‚Äëreadable Swift source fixtures directly from live runtime values.**

SwiftSnapshot turns your in‚Äëmemory objects into compilable Swift code you can commit, diff, and reuse anywhere‚Äîtests, previews, documentation, diagnostics‚Äîwithout bespoke serializers.

[![Swift](https://img.shields.io/badge/Swift-5.9+-orange.svg)](https://swift.org)
[![Platform](https://img.shields.io/badge/Platform-macOS-blue.svg)](https://www.apple.com/macos/)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)

**Status**: ‚úÖ Core runtime library implemented and tested (34 tests passing)

---

## Installation

### Swift Package Manager

Add SwiftSnapshot to your `Package.swift`:

```swift
dependencies: [
    .package(url: "https://github.com/mackoj/swift-snapshot.git", from: "0.1.0")
]
```

Then add it to your target:

```swift
.target(
    name: "YourTarget",
    dependencies: ["SwiftSnapshot"]
)
```

Or add it via Xcode: **File ‚Üí Add Packages** and enter the repository URL.

---

## Quick Start

```swift
import SwiftSnapshot

struct User {
    let id: Int
    let name: String
}

let user = User(id: 42, name: "Alice")

// Generate and export Swift code
let url = try SwiftSnapshotRuntime.export(
    instance: user,
    variableName: "testUser"
)

// Generated file contains:
// extension User {
//   static let testUser: User = User(id: 42, name: "Alice")
// }
```

---

## Key Idea

Instead of snapshotting opaque data blobs (JSON, plist, binary), SwiftSnapshot emits Swift declarations:

```swift
extension User {
  static let testUserCreation: User = User(
    id: 42,
    name: "Alice",
    role: .admin,
    isActive: true,
    tags: ["admin", "beta"]
  )
}
```

These fixtures:
- Compile (type safety)
- Diff cleanly (great review ergonomics)
- Are instantly reusable (no decoding step)
- Evolve with refactors (compiler guides updates)

---

## Runtime‚ÄëFirst Usage (Primary API)

The primary, most explicit integration path is the runtime API. The macro is optional sugar described later.

### 1. Define Your Type

```swift
enum Role {
    case admin
    case manager
    case employee
}

struct User {
    let id: Int
    var name: String
    var role: Role
    var isActive: Bool
    var tags: [String]
}
```

### 2. Capture a Snapshot at Runtime

```swift
import SwiftSnapshot

let user = User(id: 42, name: "Alice", role: .admin, isActive: true, tags: ["admin", "beta"])

let url = try SwiftSnapshotRuntime.export(
    instance: user,
    variableName: "testUserCreation",
    testName: #function // optional convenience for test contexts
)

print("Snapshot written to: \(url.path)")
```

### 3. Use the Generated Fixture

```swift
// Anywhere in your codebase
let reference = User.testUserCreation
XCTAssertTrue(reference.isActive)
```

---

## Features

### ‚úÖ Currently Implemented

- **Runtime API**: Generate Swift fixtures from any value at runtime
- **Primitive Types**: String, Int, Double, Float, Bool, Character
- **Foundation Types**: Date, UUID, URL, Data, Decimal
- **Collections**: Array, Dictionary, Set (with deterministic ordering)
- **Optional Values**: Automatic nil handling
- **Custom Types**: Structs, classes, and enums via reflection
- **Nested Structures**: Recursive rendering of complex types
- **Custom Renderers**: Extensible registry for custom type handling
- **Configuration**: Global settings for output paths, headers, formatting
- **Headers & Context**: Add documentation and custom headers to generated files
- **File Management**: Smart path resolution, overwrite protection
- **String Escaping**: Proper handling of special characters, unicode, and emoji
- **Thread-Safe**: Concurrent exports supported

### üöß Planned (Macro Layer)

The macro layer is planned for future development and will provide:

- **Type-Level Annotation**: `@SwiftSnapshot` for compile-time metadata
- **Property Attributes**: `@SnapshotIgnore`, `@SnapshotRename`, `@SnapshotRedact`
- **Optimized Generation**: Skip reflection for annotated types
- **Enhanced Enum Support**: Full associated value labels

---

## Optional Macro Layer (Future)

When implemented, the macro layer will allow per‚Äëtype convenience methods:

```swift
import SwiftSnapshot

@SwiftSnapshot(context: """
Standard product fixture used across pricing tests.
Represents typical e-commerce product with complete metadata.
""")
struct Product {
    let id: String
    let name: String
    let price: Double
    let categories: [String]
    let isAvailable: Bool
}
```

Then:

```swift
let product = Product(
    id: "prod-123",
    name: "Wireless Headphones",
    price: 199.99,
    categories: ["Electronics", "Audio"],
    isAvailable: true
)

try product.exportSnapshot(testName: #function)
// Generates extension Product { static let testProductPricing: Product = ... }
```

Use either pathway. The macro simply synthesizes the convenience `exportSnapshot(...)` forwarding into the runtime engine.

---

## Why SwiftSnapshot?

### üîç Human‚ÄëReadable
Fixtures are plain Swift‚Äîreview, search, and reason about them like any other code.

### üìù Diff Friendly
Line‚Äëlevel semantic diffs. No sprawling JSON updates or binary churn.

### ‚ôªÔ∏è Multi‚ÄëContext Reuse
Previews, tests, scripts, debugging hooks, documentation samples‚Äîno decoding layer.

### üõ°Ô∏è Type Safe
Refactors surface compiler errors instead of silent runtime mismatches.

### üì¶ Lightweight Storage
No git‚Äëlfs or compression; just fast, lean Swift source.

### üóÇÔ∏è Scalable Organization
Deterministic directory strategy with multiple override layers.

---

## Comparison to Alternatives

| Feature | SwiftSnapshot | JSON Fixtures | Snapshot Testing |
|---------|---------------|---------------|------------------|
| Human Readable | ‚úÖ Swift source | ‚ùå JSON structure | ‚ùå Binary/text blobs |
| Type Safety | ‚úÖ Compile-time | ‚ùå Runtime parsing | ‚ùå No type info |
| Version Control | ‚úÖ Meaningful diffs | ‚ö†Ô∏è Hard to review | ‚ùå Opaque changes |
| Reusability | ‚úÖ Use anywhere | ‚ö†Ô∏è Parsing required | ‚ùå Test-only |
| IDE Support | ‚úÖ Full autocomplete | ‚ùå No assistance | ‚ùå No assistance |
| Debugging | ‚úÖ Easy inspection | ‚ö†Ô∏è Mental parsing | ‚ùå External tools |

---

## Installation

### Swift Package Manager

```swift
dependencies: [
  .package(url: "https://github.com/mackoj/swift-snapshot", from: "1.0.0")
]
```

Target dependency:

```swift
.target(
  name: "YourTarget",
  dependencies: [
    .product(name: "SwiftSnapshot", package: "swift-snapshot")
  ]
)
```

### Xcode

1. File ‚Üí Add Package Dependencies
2. URL: https://github.com/mackoj/swift-snapshot
3. Add

---

## Quick Start (Runtime API Emphasis)

```swift
import SwiftSnapshot

struct Product {
    let id: String
    let name: String
    let price: Double
    let categories: [String]
    let isAvailable: Bool
}

func testProductPricing() throws {
    let product = Product(
        id: "prod-123",
        name: "Wireless Headphones",
        price: 199.99,
        categories: ["Electronics", "Audio"],
        isAvailable: true
    )

    // Writes: Tests/__Snapshots__/ProductTests/Product_testProductPricing.swift
    let fileURL = try SwiftSnapshotRuntime.export(
        instance: product,
        variableName: "testProductPricing",
        testName: #function
    )

    print("Snapshot saved: \(fileURL.lastPathComponent)")
}
```

Consume:

```swift
let testProduct = Product.testProductPricing
XCTAssertEqual(testProduct.price, 199.99)
```

---

## Advanced Runtime Options

```swift
try SwiftSnapshotRuntime.export(
    instance: user,
    variableName: "adminUser",
    fileName: "User_Admin",        // optional explicit file name (default derives from type + variable)
    outputBasePath: "/tmp/export", // override root directory for this call
    allowOverwrite: true,
    context: "Admin role baseline"
)
```

### Alternate Naming Patterns

```swift
// Durable variable name
try SwiftSnapshotRuntime.export(instance: user, variableName: "baseline")

// Explicit file name (without .swift)
try SwiftSnapshotRuntime.export(instance: user, variableName: "baseline", fileName: "User_Fixture")

// Per-test naming
try SwiftSnapshotRuntime.export(instance: user, variableName: "testUserValidation", testName: #function)
```

---

## Directory Resolution Priority

Highest ‚Üí lowest:

1. `outputBasePath:` parameter (runtime call)
2. `SwiftSnapshotConfig.setGlobalRoot(_:)`
3. Environment: `SWIFT_SNAPSHOT_ROOT`
4. Macro attribute parameter: `@SwiftSnapshot(folder: "...")`
5. Default:
   - In tests: `__Snapshots__` alongside the test file
   - Else: a temporary directory

---

## Configuration API

```swift
// Global output root
SwiftSnapshotConfig.setGlobalRoot(URL(fileURLWithPath: "/Users/dev/shared-snapshots"))

// Read current root
let root = SwiftSnapshotConfig.getGlobalRoot()
```

Environment:

```bash
export SWIFT_SNAPSHOT_ROOT=/absolute/path/to/snapshots
swift test
```

---

## Adding Context / Documentation

Macro example (optional):

```swift
@SwiftSnapshot(context: """
Represents a premium user with full access privileges.

Usage:
- Subscription flow tests
- Billing tier = 'premium'
- Updated: 2024-11-05 (added metadata)
""")
struct PremiumUser {
    let id: String
    let email: String
    let subscriptionTier: String
    let metadata: UserMetadata
}
```

Generated snippet:

```swift
extension PremiumUser {
    /// Represents a premium user with full access privileges.
    ///
    /// Usage:
    /// - Subscription flow tests
    /// - Billing tier = 'premium'
    /// - Updated: 2024-11-05 (added metadata)
    static let testPremiumUser: PremiumUser = PremiumUser(
        // ...
    )
}
```

Context rules:
- Must be a literal
- Blank leading/trailing lines trimmed
- Empty/whitespace ignored
- Preserves intentional blank lines and bullet formatting

---

## Supported Types (Built-In Rendering)

SwiftSnapshot formats:

- Primitives: `String`, `Int`, `Double`, `Bool`, `Float`, `Character`
- Foundation: `Date`, `UUID`, `URL`, `Decimal`, `Data`
- Collections: Arrays, Dictionaries, Sets
- Optionals
- `RawRepresentable` enums (via `Type(rawValue:)`)
- Structs / classes via reflection (memberwise)
- All `ExpressibleBy*Literal` conformers

Example model:

```swift
struct DataTypes {
    let text: String
    let number: Int
    let decimal: Double
    let flag: Bool
    let items: [String]
    let uniqueItems: Set<Int>
    let mapping: [String: Int]
    let optional: String?
    let optionalArray: [Int]?
    let timestamp: Date
    let data: Data
    let address: Address
    let addresses: [Address]
}
```

Snapshot excerpt:

```swift
static let sample: DataTypes = DataTypes(
  text: "Hello \"World\"",
  number: 42,
  decimal: 3.14159,
  flag: true,
  items: ["one", "two", "three"],
  uniqueItems: [1, 2, 3],
  mapping: ["key1": 1, "key2": 2],
  optional: nil,
  optionalArray: [1, 2, 3],
  timestamp: Date(timeIntervalSince1970: 1_694_534_400.0),
  data: Data([0x48, 0x65, 0x6C, 0x6C, 0x6F]),
  address: Address(street: "123 Main St", city: "Anytown"),
  addresses: [...]
)
```

---

## Custom Rendering

Override how specific types render:

```swift
import SwiftSnapshot

struct Tag { let rawValue: String }

struct TagRenderer: SnapshotValueRenderer {
    func canRender<T>(_ value: T, type: Any.Type) -> Bool {
        type == Tag.self
    }

    func render<T>(_ value: T, type: Any.Type, context: SnapshotRenderContext) -> String? {
        let mirror = Mirror(reflecting: value)
        for case let (label?, raw) in mirror.children where label == "rawValue" {
            if let s = raw as? String { return "Tag(\"\(s)\")" }
        }
        return nil
    }
}

SnapshotRenderersRegistry.shared.registerOverride(for: "Tag", renderer: TagRenderer())
```

When to override:
- Custom initializer semantics
- Enum dot shorthand desired
- Non-memberwise canonical form
- Default output not compiling / not idiomatic

Built‚Äëins already handle the common primitives and foundational types.

---

## API Reference (Core Runtime)

```swift
public struct SwiftSnapshotRuntime {

  @discardableResult
  public static func export<T>(
      instance: T,
      variableName: String,
      fileName: String? = nil,
      outputBasePath: String? = nil,
      allowOverwrite: Bool = true,
      context: String? = nil,
      testName: String? = nil,
      line: UInt = #line,
      fileID: StaticString = #fileID,
      filePath: StaticString = #filePath
  ) throws -> URL

  public static func generateSwiftCode<T>(
      instance: T,
      variableName: String
  ) throws -> String
}
```

Parameters:
- variableName: Identifier inside generated extension
- fileName: Override file (no `.swift` needed)
- outputBasePath: Per-call directory override
- allowOverwrite: Fail or replace existing
- context: Documentation block
- testName: Optional grouping under test context path
- fileID/filePath/line: Source location for directory inference

Returns: URL to created `.swift` file.

---

## Examples

### XCTest Integration

```swift
final class UserServiceTests: XCTestCase {

    func testUserSerialization() throws {
        let user = User(
            id: "user-123",
            name: "John Doe",
            email: "john@example.com",
            preferences: UserPreferences(theme: .dark, notifications: true)
        )

        try SwiftSnapshotRuntime.export(instance: user, variableName: "testUserSerialization", testName: #function)

        let snapshot = User.testUserSerialization
        let encoded = try JSONEncoder().encode(snapshot)
        let decoded = try JSONDecoder().decode(User.self, from: encoded)

        XCTAssertEqual(decoded.id, snapshot.id)
    }
}
```

### SwiftUI Previews

```swift
struct UserProfileView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            UserProfileView(user: User.standardUser)
                .previewDisplayName("Standard")

            UserProfileView(user: User.adminUser)
                .previewDisplayName("Admin")
        }
    }
}
```

### Debug Hot Path

```swift
func processOrders(_ orders: [Order]) -> ResultSummary {
    let summary = internalProcess(orders)

    #if DEBUG
    if let first = orders.first {
        try? SwiftSnapshotRuntime.export(instance: first, variableName: "debugFirstOrder")
    }
    try? SwiftSnapshotRuntime.export(instance: summary, variableName: "debugProcessingResult")
    #endif

    return summary
}
```

---

## Formatting Control

SwiftSnapshot formats generated files using a hierarchical configuration:

Search order:
1. `.swift-snapshot-format`
2. `.editorconfig`
3. Built‚Äëin defaults

Supported keys:

| Setting | Values | Default | Purpose |
|---------|--------|---------|---------|
| indent_style | space | space | Indent style |
| indent_size | integer | 4 | Spaces per indent |
| end_of_line | lf / crlf / cr | lf | Line endings |
| insert_final_newline | true/false | true | EOF newline |
| trim_trailing_whitespace | true/false | true | Strip trailing spaces |

Example `.swift-snapshot-format`:

```ini
indent_style = space
indent_size = 2
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
```

EditorConfig example:

```ini
root = true

[*.swift]
indent_style = space
indent_size = 2
end_of_line = lf
insert_final_newline = true
```

---
## Acknowledgments

- Inspired by ideas from snapshot testing ecosystems (e.g. pointfreeco)
- Path resolution strategy influenced by swift-snapshot-testing
- Built atop SwiftSyntax for any macro-powered conveniences

---

## License

MIT. See [LICENSE](LICENSE) for details.